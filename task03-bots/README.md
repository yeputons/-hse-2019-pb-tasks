# Боты (`task03-bots`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
    1. [Часть 1](#часть-1)
    1. [Часть 2](#часть-2)
    1. [Часть 3: `cli_single.py`](#часть-3-cli_singlepy)
    1. [Часть 4: крестики-нолики](#часть-4-крестики-нолики)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Разумная попытка](#разумная-попытка)
    1. [Блокирующее](#блокирующее)
    1. [Часть 3: `cli_single.py`](#часть-3-cli_singlepy-1)
    1. [Часть 4: крестики-нолики](#часть-4-крестики-нолики-1)
        1. [Общее](#общее)
        1. [Обработка команд](#обработка-команд)
        1. [Пример](#пример)
        1. [Автоматические тесты](#автоматические-тесты)
1. [Сдача задания](#сдача-задания)
    1. [Процесс](#процесс)
    1. [Сроки](#сроки)
    1. [Система оценки](#система-оценки)

## Задание
Это задание состоит четырёх независимых частей, ни одна из частей не является блокирующей.
Однако первые три части оцениваются в 2 балла в сумме, не требуют тестирования и больше служат разминкой.

### Часть 1
Предоставленный скрипт `cli_multiple.py` позволяет эмулировать в консоли
общение нескольких пользователей с `ChatBot`.
Замените `ChatBot` на `AlarmUserHandler` или `TicTacToeUserHandler`
(если у вас реализована часть 4).
Разрешается менять только строчку вида `bot = ...` и импорты.

### Часть 2
Предоставленное приложение `gui_multiple.py` позволяет эмулировать
в графическом интерфейсе общение нескольких пользователей с `AlarmUserHandler`.
Замените `AlarmUserHandler` на `ChatBot`.
Разрешается менять только строчку вида `bot = ...` и импорты.

### Часть 3: `cli_single.py`
Реализуйте функцию `main()` (а также, при необходимости, другие функции)
в файле `cli_single.py`.

Скрипт `cli_single.py` должен работать аналогично `cli_multiple.py`, однако
эмулировать общение не нескольких пользователей с ботом, а лишь одного.
Это имеет смысл только для ботов, которые работают с пользователями независимо,
поэтому скрипт должен вызывать не методы интерфейса `Bot`,
а методы интерфейса `UserHandler` напрямую.

В частности, это означает, что `cli_single.py` может работать с `AlarmUserHandler`,
`CalculatorUserHandler` и `TicTacToeUserHandler`, но не с `ChatBot`.
Ваш скрипт не должен быть завязан на детали реализации,
то есть заменить одного бота другим должно быть очень просто,
как и в `cli_multiple.py`.

Не требуется писать автоматические тесты для `cli_single.py`.

### Часть 4: крестики-нолики
Реализуйте нового бота для игры в крестики-нолики 3x3 на двоих в классе `TicTacToeUserHandler`.
Пользователь сам ходит за двух игроков, не требуется реализовывать стратегию игры.

Бот должен позволять пользователю начать новую игру в любой момент,
по очереди ходить за крестики и нолики, сообщать о конце игры и победителе,
а также сообщать о некоторых ошибках.

## Требования к корректности решения
### Разумная попытка
Преподаватели в некоторых группах могут требовать сделать "разумную попытку" к определённому сроку.
Под этим понимается:

1. Все присланные файлы не имеют синтаксических ошибок.
1. Предоставленные в задании тесты проходят без их изменений при запуске команды `pytest`.
1. Отсутствуют изменения файлов, кроме: `cli_multiple.py`, `gui_multiple.py`, `cli_single.py`,
   `tictactoe_user_handler.py`, `tictactoe_user_handler_test.py`, а также
   `calculator_user_handler.py` или `calculator_user_handler_test.py`
    * Содержимое файлов `calculator_user_handler*.py` **не влияет на оценку**, если только оно не нарушает блокирующие требования.
1. Решения частей 1-2:
    * Не требуют изменений в файлах с логикой бота.
    * Не изменяют существенным образом поведение файлов: меняют только строчку вида `bot = ...` в требуемых файлах и импорты.
1. Решение части 3:
    * Позволяет использовать любую логику бота с интерфейсом `UserHandler` без изменений.
1. Решение части 4:
    * Не требует изменений в файлах, кроме `tictactoe_user_handler*.py`,
      кроме изменений в файлах `cli_multiple.py`/`gui_multiple.py`/`cli_single.py`,
      если вы в соответствующей части задания выбрали там `TicTacToeUserHandler`.
    * Использует реализованную логику игры из файла `tictactoe.py`.
    * Сделано через интерфейс `UserHandler`, а не `Bot`.
    * Удовлетворяет требованиям `UserHandler`.
    * Не требует каких-либо нестандартных глобальных переменных, функций или объектов.
    * Не взаимодействует со стандартным вводом или выводом.

### Блокирующее
Если хотя бы одно из следующих требований не выполняется, вы можете получить не более 30% баллов за задание:

1. Попытка является "разумной" (смотри выше).
1. Команда `flake8 --max-line-length=100` (с установленными `pep8-naming` и `flake8-quotes`) не выдаёт ошибок ни в одном из файлов.
1. Команда `pylint --max-line-length=100 --disable=invalid-name,missing-docstring,global-statement,too-many-lines,R --enable=simplifiable-if-statement,redefined-variable-type` не выдаёт ошибок ни в одном из файлов.
   Это требование можно ослабить, если вы предоставите практику пример, где это команда выдаёт неразумную, на ваш взгляд, рекомендацию.
1. Команда `mypy --ignore-missing-imports` не выдаёт ошибок ни в одном из файлов.
1. Все ваши тесты запускаются командой `pytest` и проходят под Windows, Linux и Mac.
1. Каждая содержательная команда в `tictactoe_user_handler.py` (не обработка ошибки) должна вызываться
   хотя бы в одном тесте (неважно, юнит- или интеграционном).
   Проверяйте при помощи `pytest-cov`.
1. Должны быть указаны типы всех параметров всех функций (кроме параметров тестов `test_*`) и типы их возвращаемых значений для команды `mypy`.
1. В качестве shebang в Python используется `#!/usr/bin/env python3`.
1. В неисполняемых файлах shebang отсутствует.

Если вы обнаружили, что эти требования не соблюдаются в файлах, которые вам нельзя менять — срочно сообщите.

### Часть 3: `cli_single.py`
Скрипт `cli_single.py` должен предоставлять консольный интерфейс взаимодействия с фиксированной
реализацией интерфейса `UserHandler`, при этом, однако, не завязываясь на конкретную реализацию.

Каждая строчка стандартного потока ввода считается отдельным сообщением от пользователя
и подаётся в интерфейс `UserHandler` без изменений, за исключением удаления перевода строки.

Каждое сообщение, которое отправляет пользователю `UserHandler` через `send_message`, выводится
в стандартный поток вывода, после чего выводится дополнительный перевод строки `\n`.
Таким образом, каждое выведенное сообщение получается в ровно одной отдельной строчке
(если только внутри сообщения не было переводов строк).

Пример сеанса работы с командой `./cli_single.py`, которая эмулирует общение одного пользователя с `AlarmUserHandler`:

| Стандартный ввод | Стандартный вывод |
| ---------------- | ----------------- |
| <pre>10 1<br>1<br>2</pre> | <pre>Please send number of seconds: pause before new alarm<br>Alarm!<br>Alarm!</pre> |

Здесь бот сначала не понял команду `10 1`, а вот следующие две команды понял.
Через секунду после первой появляется первый `Alarm!`, а через две секунды после второй команды — второй `Alarm!`.

### Часть 4: крестики-нолики
#### Общее

1. Бот целиком реализуется в классе `TicTacToeUserHandler` в файле `tictactoe_user_handler.py`.
    1. Требуется реализовать и использовать все предоставленные заглушки методов.
    1. Запрещается изменять сигнатуры предоставленных методов и типы полей.
1. Запрещается реализовывать логику игры в крестики-нолики самостоятельно,
  используйте готовые методы из класса `TicTacToe` в файле `tictactoe.py`.
    1. Запрещается напрямую обращаться к полю `field` класса `TicTacToe`,
      кроме как в методе `send_field`.
1. В поле `game` должна храниться текущая игра в крестики-нолики или `None`,
  если игра ещё не была начата или уже завершилась.

#### Обработка команд

1. При поступлении от пользователя команды `start` должна начинаться новая игра
   независимо от наличия и состояния старой.
1. Сразу после начала игры пользователю отправляется поле 3x3 в следующем формате:
    * Сообщение состоит из 11 символов: 3 символа на каждую из трёх строк и два разделителя новой строки между ними.
    * Пустая клетка обозначается точкой (`.`, ASCII-код 46).
    * Клетка с крестиком обозначается заглавной латинской буквой `X` (ASCII-код 88).
    * Клетка с ноликом обозначается заглавной латинской буквой `O` (ASCII-код 79).
1. Если не в процессе игры приходит любая команда, кроме `start`, пользователю
   отправляется сообщение `Game is not started`.
1. В процессе игры пользователь делает ход командой `X 0 1`, где `X` или `O` — это текущий игрок,
   `0` — номер столбца, а `1` — номер строки.
   Нумерация идёт от 0 до 2.
1. Если ход невозможно сделать (метод `can_make_turn` вернул `False`), то пользователю должно
   быть отправлено сообщение `Invalid turn`.
    * Прочие нарушения формата команд в процессе игры можно не обрабатывать.
1. После каждого _успешного_ хода пользователю отправляется изменённое поле в том же
   формате, что и в начале игры.
   При некорректном ходе поле не отправляется.
1. Если после отправки поля обнаруживается, что игра закончилась, требуется отправить
   отдельным сообщением информацию о победителе и завершить игру:
    * `Game is finished, draw` — ничья.
    * `Game is finished, X wins` — победили крестики.
    * `Game is finished, O wins` — победили нолики.
    * Все последующие команды до команды `start` должны немедленно возвращать `Game is not started`.

#### Пример
Если запустить `./cli_single.py` с корректным `TicTacToeUserHandler.py`, то может произойти следующий сеанс игры:

| Стандартный ввод | Стандартный вывод | Комментарий |
| ---------------- | ----------------- | ----------- |
| `hi` | `Game is not started` | Неверная команда |
| `X 1 1` | `Game is not started` | Неверная команда, игра не начата |
| `start` | <pre>...<br>...<br>...</pre> | Игра началась |
| `X 1 1` | <pre>...<br>.X.<br>...<pre> | Походили крестики |
| `O 0 1` | <pre>...<br>OX.<br>...</pre> | Походили нолики |
| `O 0 0` | `Invalid turn` | Нолики не могут ходить два раза подряд |
| `start` | <pre>...<br>...<br>...</pre> | Начата новая игра, старая забыта |

#### Автоматические тесты:
Вам требуется реализовать автоматические интеграционные тесты для `TicTacToeUserHandler`
в файле `tictactoe_user_handler_test.py` по аналогии с `chat_bot_test.py` или, чуть точнее,
с `calculator_user_handler_test.py`, реализованным на практике.

* Тесты должны использовать stub-классы вместо реального метода `send_message` или захвата
  стандартного вывода при помощи `capsys`
* Тесты должны _полностью_ проверять поведение класса.
  В частности, методы `assert_called_once_with`, `assert_called_with`
  и `assert_has_calls` бесполезны, потому что не проверяют всю
  последовательность вызовов.
* Не требуется проверять детали, не указанные в задании.
  Например, поведение при команде в неверном формате (вроде `X00`) при начатой игре.

## Сдача задания
### Процесс
Задание сдаётся **только** через систему Pull Request в GitHub.

1. Создайте fork этого репозитория (если вы ещё не сделали этого).
1. В своём fork создайте ветку `task03-bots-solution` на основе последнего коммита из ветки `master`.
1. В ветке `task03-bots-solution` замените нужные файлы на решение задачи.
    * Вы можете делать несколько коммитов.
    * Чистая история очень рекомендуется для упрощения проверки, но не требуется ни для корректности, ни для стиля.
    * Не должно быть коммитов, изменяющих какие-либо файлы, кроме кроме разрешённых, и `.gitignore` в корне репозитория.
    * Не должно быть коммитов, добавляющих новые файлы, например, папку `.idea`, файлы `*.iml` или `*.pyc`.
       Используйте `.gitignore` в корне репозитория.
1. Создайте Pull Request в ветку `master` этого репозитория с нужным заголовком (`Task03-bots, GroupXX, Фамилия Имя`)
   из ветки `task03-bots-solution` вашего репозитория.
    * В названии Pull Request не допускаются сокращения, перестановка слов, отсутствие запятой, пробелов, лишние пробелы,
      неверный регистр, написание имени транслитом, неверный порядок имени и фамилии.
1. Убедитесь, что `@yeputons-bot` добавил к вашему PR метки, соответствующие
   номеру задания, номеру группы, а также `needs-grading` и назначил review
   на вашего преподавателя.
1. Убедитесь, что все автоматические проверки на Travis пройдены, в противном случае
   ваше решение гарантированно не удовлетворяет некоторым блокирующим требованиям.

Последующие попытки:

1. Не помечайте комментарии преподавателя как `Resolved`, если об этом
   нет явной договорённости.
1. При желании ответьте на замечания преподавателя индивидуально.
1. Оставьте в PR отдельное сообщение, начинающееся со строчки
   `@yeputons-bot, исправлено.`
1. Убедитесь, что `@yeputons-bot` добавил к вашему PR метку `needs-grading`
   и назначил review на вашего преподавателя.

Если вы сдаёте с нарушением процесса (например, неверный заголовок Pull Request),
то ваша посылка может быть не проверена, пока вы не исправите формат.

### Сроки
Задание выдано 21.11.2019 (четверг).

Срок сдачи — **29.11.2019 (пятница) 22:59 по Москве**.

В некоторых группах к сроку сдачи требуется лишь сделать посылку,
а доделывать можно потом без последствий; в некоторых может требоваться
исправить все замечания до срока сдачи.
Уточняйте правила у своего преподавателя.

## Система оценки
Задание оценивается в 10 баллов:

| Часть | Корректность | Стиль кода и тестов | Качество тестов |
| ----- | ------------ | ------------------- | --------------- |
| 1 | 0.25 | 0.25 | 0 |
| 2 | 0.25 | 0.25 | 0 |
| 3 (`cli_single.py`) | 0.5 | 0.5 | 0 |
| 4 (крестики-нолики) | 3 | 3 | 2 |
| **Итого** | **4** | **4** | **2** |

Обратите внимание, что тесты требуются только в части 4,
а файлы `calculator_user_handler*.py` не оцениваются,
за исключением блокирующих требований (например, автопроверок на Travis).

В каждой группе независимо устанавливаются баллы за посылки, сделанные
после срока сдачи, за частичное выполнение задания, за выполненную
первую итерацию без второй.
Уточняйте правила у своего преподавателя.
